{# This template provides a set of standard macros which should be used to certain create html-elements. #}

{# Macro to load JavaScript files on a per-template basis. This macro should be used the following way in templates, to
   add the correct <script src="..."> tags to the HTML header:

       {% block scripts %}{{ util.cdedb_script('SCRIPTFILE') }}{% endblock %}

   This Macro takes care of including the correct dependencies (other script files (or CSS stylesheets) required for the
   target script) and including each script only once. #}
{% set script_files = [] %}
{% macro cdedb_script(script) %}
    {%- if not script in script_files %}
        {%- if script == 'cdedb_queryform.js' %}
            {{- cdedb_script('selectize/selectize.min.js') }}
        {%- elif script == 'selectize/selectize.min.js' %}
            <link rel="stylesheet" href="{{ staticurl("selectize/selectize.bootstrap3.css") }}" />
        {%- elif script == 'cdedb_searchpersona.js' %}
            {{- cdedb_script('selectize/selectize.min.js') }}
        {%- elif script == 'cdedb_manage_participants.js' %}
            {{- cdedb_script('selectize/selectize.min.js') }}
        {%- endif %}
        <script  src="{{ staticurl(script) }}"></script>
        {%- do script_files.append(script) %}
    {%- endif %}
{%- endmacro %}


{# ############################################ #
 # General helper macros for links, icons, etc. #
 # ############################################ #}

{# A really generic macro to generate <a href=""></a> tags.

   ref        The full URL to reference to
   label      The Link text. (Please consider to add some sr-only text, if this is empty, to maintain a11y.
   readonly   If True, a simple text instead of a link is added
   icon       If set, the icon is prepended to the link text. Must be the short icon name, as passed to make_icon()
   aclass     Additional HTML/CSS classes to be added to the link tag
   active     If this link is part of a navigation menu, the current active page/tag can be highlighted by setting this
              to True
   title      A HTML `title` attribute (hover text) to add to the link
   rel        Allows to set the rel attribute #}
{% macro href(ref, label, readonly=False, icon=none, aclass='', active=False, title=none, rel=none, anid="") -%}
{% if readonly %}<span {% else %}<a href="{{ ref }}" {% if rel %} rel="{{ rel }}" {% endif %}{% endif %}
{{ dict(
    class=" ".join([
        aclass,
        "active" if active else "",
        ("disabled" if 'btn' in aclass else "link-disabled") if readonly else "",
    ]),
    title=title,
    id=anid,
    **{ "aria-current": "page" if active }
)|xmlattr }}{# We use the `active` attribute for navigation only #}>
{{- make_icon(icon) + "&nbsp;"|s if icon }}{{ label }}
{%- if readonly %}</span>{%- else -%}</a>{% endif %}
{%- endmacro %}

{# Macro to place a Fontawesome icon

   icon       The icon's name. See https://fontawesome.com/icons for a list of available icons.
              Only the distinguishing part of the icon's CSS class is required (e.g. "ok" instead of "fas fa-ok").
              If the icon contains a space the full class is required. (e.g. "far fa-star")
   aclass     An additonal HTML/CSS class to add to the icon. Useful if you want to access the icon via JavaScript
   title      A HTML `title` attribute (hover text) to add to the icon.
              This is also used as arialabel, if you don't provide one explicitly.
   arialabel  A screenreader-only text to append to the icon.
              Please make sure, to provide one (or a title) for every semantically important icon in support of a11y. #}
{% macro make_icon(icon, fixed_width=True, aclass=none, title=none, arialabel=none) -%}
    <span{{ dict(
        class=" ".join([
            aclass or '',
            "fas fa-{}".format(icon) if " " not in icon else icon,
            "fa-fw" if fixed_width else "",
        ]),
        title=title,
        **{ "aria-hidden": "true" }
    )|xmlattr }}></span>
    {%- if arialabel or title %}<span class="sr-only">{{ arialabel or title }}</span>{% endif %}
{%- endmacro %}

{% macro gettext_country(country) -%}
    {%- if country %}
        {{- gettext("CountryCodes." + country) -}}
    {% endif %}
{%- endmacro %}


{# ############## #
 # Layout helpers #
 # ############## #}

{% macro bootstrap_panel(title="", aclass="panel-default", icon=none, anid=none) %}
    <div{{ dict(class="panel " + aclass, id=anid)|xmlattr }}>
        {%- if title or icon %}
            <div class="panel-heading">
                <h3 class="panel-title">{{ make_icon(icon) + " " if icon }}{{ title }}</h3>
            </div>
        {%- endif %}
        <div class="panel-body">{{- caller() }}</div>
    </div>
{%- endmacro %}


{# ######################################## #
 # Special purpose links and element macros #
 # ######################################## #}

{# Macro to visually represent an immutable boolean value

   checked    The actual boolean value to show
   anid       The HTML id to add to the element. Useful for testing purposes.
   titles     An optional list/tuple of two elements: The HTML `title` attribute (hover text) for the False state and
              the title attribute for the True state. The title is also used as an screenreader-readable hidden text.
              If you don't provide `titles` and the icon is semantically important, please make sure to make the value
              accessible to screen readers by any other means. #}
{% macro deko_checkbox(checked, anid=none, titles=[]) %}
    {% set title = titles[checked | int] %}
    <span{{ dict(
        class="fas fa-check-circle" if checked else "far fa-times-circle",
        id=anid,
        title=title,
        **{
            "data-checked": checked,
            "aria-hidden": "true"
        })|xmlattr }}></span>
    {% if title %}<span class="sr-only">{{ title }}</span>{% endif %}
{%- endmacro %}

{# Special tri-state macro to represent subscription states

   In contrast to the deko_checkbox, this represents the pending state of someone who has requested subscription by
   an empty circle. Otherwise, this macro is functionally equivalent.
#}
{% macro state_checkbox(state) %}
    {% if state in enums["SubscriptionState"].subscribing_states() %}
        <span class="fas fa-check-circle" title="{{ gettext("subscribed") }}" aria-hidden="true"></span>
    {% elif state == enums["SubscriptionState"].pending %}
        <span class="far fa-circle" title="{{ gettext("pending") }}" aria-hidden="true"></span>
    {% else %}
        <span class="far fa-times-circle" title="{{ gettext("not subscribed") }}" aria-hidden="true"></span>
    {% endif %}
{% endmacro %}

{# Create a link to a persona's profile page, labeled with some variant of their name

   persona:                 The persona data. Must be a dict containing (at least) the following keys:
                            'id', 'title', 'given_names', 'display_name', 'family_name', 'name_supplement'.
   only_given_names:        see 'persona_name' macro
   only_display_name:       see 'persona_name' macro
   given_and_display_names: see 'persona_name' macro
   with_family_name:        see 'persona_name' macro
   with_titles:             see 'persona_name' macro
   quote_me:                see show_user_link()
   event_id:                see show_user_link()
   ml_id:                   see show_user_link()
   aclass:                  see 'href' macro
   readonly:                see 'href' macro
#}
{% macro persona_anchor(persona, only_given_names=False, only_display_name=False, given_and_display_names=False,
                        with_family_name=True, with_titles=False, quote_me=False, event_id=none, ml_id=none,
                        aclass='', readonly=False) %}
    {{- href(show_user_link(user, persona['id'], quote_me, event_id=event_id, ml_id=ml_id),
            persona_name(persona, only_given_names, only_display_name, given_and_display_names, with_family_name),
            aclass=aclass, readonly=readonly) -}}
{% endmacro %}

{# Display the name of a given persona

   Displaying names is rather complicated, esp. because of our distinction between given_names and display_name. Thus,
   this macro includes some logic to display a person's name correctly, depending on the context and the person's
   display name. For a full specification, which name variant should be used in which context, see the documentation
   page about "User Experience Conventions".

   For usage in Python frontend code, the `cdedb.frontend.common.make_persona_name()` function implements the same
   logic.

   persona:                 The persona data. Must be a dict containing (at least) the following keys:
                            'title', 'given_names', 'display_name', 'family_name', 'name_supplement'.
   only_given_names:        If True, the display_name is ignored. Should only be used in a legal/formal context.
   only_display_name:       If True, the given_names are ignored. Should be used when the person is addressed directly.
   given_and_display_names: If True, the display of all given_names and the display name (if not equal) is enforced.
                            This is the "long" version of the name.
   with_family_name:        If True (default), the family name is included in the macro output
   with_titles:             If True, the person's title(s) and name supplement are included in the macro output
#}
{% macro persona_name(persona, only_given_names=False, only_display_name=False, given_and_display_names=False,
                      with_family_name=True, with_titles=False) %}
    {%- set display_name = persona['display_name'] %}
    {%- set given_names = persona['given_names'] %}
    {%- if with_titles and persona['title'] %}{{ persona['title'] }}&nbsp;{% endif %}
    {%- if only_given_names -%}
        {{ given_names }}
    {%- elif only_display_name -%}
        {{ display_name }}
    {%- elif given_and_display_names %}
        {%- if display_name in given_names %}
            {%- if not display_name or display_name == given_names -%}
                {{ given_names }}
            {%- else -%}
                {{ '<em>{}</em>'.format(display_name|e).join((given_names|e).split(display_name|e))|s }}
            {%- endif %}
        {%- else -%}
            {{ given_names }} ({{ display_name }})
        {%- endif -%}
    {% else %}
        {%- if display_name in given_names -%}
            {{ display_name }}
        {%- else -%}
            {{ given_names }}
        {%- endif -%}
    {% endif %}
    {%- if with_family_name %} {{ persona['family_name'] }}{% endif %}
    {%- if with_titles and persona['name_supplement'] %}&nbsp;{{ persona['name_supplement'] }}{% endif -%}
{% endmacro %}

{% macro tel_link(phonenumber) %}
    {% set linknumber = phonenumber|replace(" ", "")|replace("(", "")|replace(")", "")|replace("/", "") %}
    {%- if linknumber.startswith("+") -%}
        {{ href('tel:%s'|format(linknumber), phonenumber) }}
    {%- elif linknumber.startswith("0") -%}
        {{ href('tel:%s'|format(linknumber|replace("0", "+49", 1)), phonenumber) }}
    {%- endif -%}
{% endmacro %}

{# Macro to generate breadcrumb links. Should be used like this in individual templates:

       {% block breadcrumb %}
            {{ super() }}
            {{ util.breadcrumb_link(cdedblink("realm/intermediate_endpoint"), "Intermediate label") }}
            {{ util.breadcrumb_link(cdedblink("realm/endpoint"), "Page link label", active=True) }}
       {% endblock %}

   Where the displayed link texts (`label`) directly correspond to the navigation links or button labels, the user has
   to follow to reach this page.

   The active=True parameter should be used exaclty for the link to the current page, which is alwas the las Breadcrumb
   link. The readonly=True parameters should be used for rare cases, in which an intermediate page – which is normally
   required to navigate to the currente page – is not accessible to the user (e.g. visible course listing of not yet
   published event, only reachable via direct link).

   An icon (given by its name – see comments of make_icon() macro) should exactly be used, when the Breadcrumb link
   represents a page of a dynamic object (e.g. a persona, an event, a course) and is labeled with this object's
   name/title. In this case the icon should represent the type of the named object. For a complex example, take a look
   at the event/change_course template.
  #}
{% macro breadcrumb_link(ref, label, icon=none, active=False, readonly=False) %}
    {%- if active or readonly -%} {#- TODO use actual bootstrap readonly anchor -#}
        <li{% if active %} class="active" aria-current="location"{% endif %}>
            {{ make_icon(icon) if icon }}
            {{ label -}}
        </li>
    {%- else -%}
        <li><a href="{{ ref }}">
            {{ make_icon(icon) if icon }}
            {{ label -}}
        </a></li>
    {%- endif -%}
{% endmacro %}

{# Helper macro to create a large, left-floated 'Help' button, linking to the off-page documentation as referenced by
   docurl(). #}
{% macro _doclink(topic, anchor=none) %}
    <a href="{{ docurl(topic, anchor) }}" class="btn btn-info pull-right" target="_blank">
        {{ make_icon('question-circle') }}
        {% trans %}Help{% endtrans %}
        <span class="sr-only">{% trans %}for this site{% endtrans %}</span>
    </a>
{%- endmacro %}


{# ########################################################################################### #
 # Macros to add additional information (infotext, validation errors, ...) around input fields #
 # ########################################################################################### #}

{% macro format_error(error) %}
    {%- if error.args|length == 1 %}
        {{- gettext(error.args[0]|string) }}<br />
    {%- elif error.args|length == 2 %}
        {{- gettext(error.args[0]|string)|format(**error.args[1]) }}<br />
    {%- elif error.args|length == 0 %}
        {#- Display nothing if no message was supplied. #}
    {%- else %}
        {% trans %}Malformed error.{% endtrans %}<br />
    {%- endif %}
{%- endmacro %}

{% macro output_info(info, link) %}
    {%- if info %}
        <p class="help-block no-color">
            {{ make_icon('info-circle') }} {{ info }}
            {{ link }}
        </p>
    {%- endif %}
{%- endmacro %}

{% macro has_errors(name) %}
    {%- if name in errors %}
        {{- "has-warning" if is_warning(name) else "has-error"}}
    {%- endif -%}
{% endmacro %}

{% macro output_errors(name, displayerrors=True, wrapper=False) %}
    {%- if displayerrors and name in errors %}
        {%- if wrapper %}
            <div class="{{ "has-warning" if is_warning(name) else "has-error"}}">
        {% endif %}
        {# TODO sort #}
        {%- if caller %}{{- caller() }}{% endif %}
        {%- for error in errors.get(name, []) if error and error.args %}
            <div class="help-block">
                {{ make_icon('exclamation-circle') }}
                {{ format_error(error) }}
            </div>
        {%- endfor %}
        {%- if wrapper %}</div>{% endif %}
    {%- elif caller %}
        {{- caller() }}
    {%- endif %}
{%- endmacro %}

{% macro markdown_preview(anid) %}
    <p class="help-block no-color">
        {{ make_icon('fab fa-markdown') }} {% trans %}Supports Markdown.{% endtrans %}
        <span class="mdjs" style="display: none;">
            <a id="{{ anid }}-mdpreview" title="{% trans %}Open Markdown Preview{% endtrans %}">
                {{ gettext("Preview") }}
            </a> |
        </span>
        {{ href(docurl("Handbuch_Markdown"), gettext("Tutorial"), title=gettext("Short Markdown summary")) }}
    </p>
    <script nonce="{{ csp_nonce }}">
        $("#{{ anid }}").cdedbMarkdownPreview("{{ cdedblink("core/markdown_parse")|e }}",
                                              {{ {"title": gettext("Markdown Preview"),
                                                  "loading": gettext("Loading..."),
                                                  "close": gettext("Close") }|tojson }})
    </script>
{%- endmacro %}

{# ################### #
 # (Form) input macros #
 # ################### #}

{# The input_* macros generate a blank input field of the given type. Note that some input types don't have an own macro
   but can be produced by passing an additional parameter to another macro:

   * password: input_text(..., type="password")
   * date etc.: input_text(..., type="date")
   * radio: input_checkbox(..., radio=True)

   The form_input_* wraps the specific input macro and adds some divs, label and error output. These macros are meant to
   be used inside an form.form-horizontal. (If you want to use it in a non-horizontal form, you may pass the
   horizontal=False parameter.)

   Note that the readonly parameter of these macros sets the disabled flag. The HTML readonly attribute should only be
   used for purely cosmetical changes, admin views in particular. Furthermore, it is not supported for all input types,
   hence we fake it in some cases by introducing an additional hidden field while renaming the previous one.
   To make a use of the readonly attribute a concious decision, we obsure it by the name actualreadonly. #}
{% macro input_hidden(name, value=none, defaultvalue='', anid=none, aclass=none) %}
    <input{{ dict(
        type="hidden",
        name=name,
        value=values.get(name, defaultvalue) if value is none else value,
        id=anid,
        class=aclass,
    )|xmlattr }}/>
{% endmacro %}

{% macro form_input_general(name=none, label='', anid=none, small=False, info='', displayerrors=True,
        horizontal=True, labelid=none, addon='', markdown=False) %}
    <div class="form-group {% if name in errors %}
                               {% if is_warning(name) %}
                                   has-warning
                               {% else %}
                                   has-error
                               {% endif %}
                           {% endif %}">
        {%- if label %}
            <label{{ dict(
                id=labelid,
                for=anid,
                class=(("col-sm-2" if small else "col-sm-4") if horizontal else "") + " control-label",
            )|xmlattr }}>{{ label }}</label>
        {%- endif %}
        {%- if horizontal %}
            <div class="
                {{ "col-sm-6" if small else "col-sm-8" }}
                {{ ("col-sm-offset-2" if small else "col-sm-offset-4") if not label }}
            ">
        {%- endif %}
        {% if addon %}<div class="input-group">{% endif %}
            {{- caller() }}
        {% if addon %}<span class="input-group-addon">{{ addon }}</span></div>{% endif %}
            {{- output_errors(name, displayerrors) }}
            {{- output_info(info) }}
        {%- if markdown %}{{ markdown_preview(anid) }}{% endif %}
        {%- if horizontal %}</div>{% endif %}
    </div>
{%- endmacro %}

{% macro input_text(name, readonly=False, actualreadonly=False, defaultvalue='', anid=none, aclass='form-control',
        maxlength=none, type='text', placeholder=none, arialabel=none, attributes='') %}
    <input{{ dict(
        type=type if type != 'iban' else 'text',
        name=name,
        id=anid,
        class=aclass,
        maxlength=maxlength,
        placeholder=placeholder,
        disabled="disabled" if readonly,
        readonly="readonly" if actualreadonly,
        **{ 'aria-label': arialabel }
    )|xmlattr }}
        {%- if type == 'tel' %}
            placeholder="+49 1234 5678910"
            pattern="\+?[0-9 ()]+"
            title="{{ gettext("Phone number in the format +49 1234 5678910") }}"
        {%- elif type == 'datetime-local' %}
            placeholder="YYYY-MM-DD HH:MM"
            pattern="[0-9]{4}-[0-9]{2}-[0-9]{2}( |T)[0-9]{2}:[0-9]{2}(:[0-9]{2})?"
            title="{{ gettext("Datetime in the format YYYY-MM-DD HH:MM") }}"
        {%- elif type == 'iban' %}
            placeholder="DE22100100500123456789"
            pattern="[A-Za-z]{2} ?[0-9]{2}( ?[0-9A-Za-z]){8,30}"
            title="{{ gettext("IBAN in the usual format, spaces are allowed") }}"
        {%- endif %}
        {%- if type == 'date' %}
            value="{{ values.get(name, defaultvalue)|date('%Y-%m-%d', passthrough=True) }}"
        {%- elif type == 'datetime-local' %}
            value="{{ values.get(name, defaultvalue)|datetime('%Y-%m-%dT%H:%M:%S', passthrough=True) }}"
        {%- elif type != 'password' %}
            value="{{ values.get(name, defaultvalue) }}"
        {%- endif %}
        {{ attributes }}/>
{%- endmacro %}

{% macro form_input_text(name, label='', info='', displayerrors=True, readonly=False, actualreadonly=False,
        defaultvalue='', anid=none, maxlength=none, type='text', placeholder=none, small=False, horizontal=True,
        aclass="", attributes='', addon='', markdown=False) %}
    {%- set anid = anid or "input-text-{}".format(name) %}
    {%- call form_input_general(name, label, anid, small, info, displayerrors, horizontal, addon=addon, markdown=markdown) %}
        {{- input_text(name, readonly, actualreadonly, defaultvalue, anid, maxlength=maxlength, type=type,
                placeholder=placeholder, aclass="form-control " + aclass, attributes=attributes) }}
    {%- endcall %}
{%- endmacro %}

{% macro input_file(name, readonly=False, defaultvalue='', anid=none, aclass='form-control', accept=none, arialabel=none) %}
    <input{{ dict(
        type="file",
        name=name,
        id=anid,
        class=aclass,
        accept=accept,
        disabled="disabled" if readonly,
        **{ 'aria-label': arialabel }
    )|xmlattr }}/>
{%- endmacro %}

{% macro form_input_file(name, label='', info='', displayerrors=True, readonly=False, accept=none, anid=none,
        aclass=none, small=False, horizontal=True) %}
    {%- set anid = anid or "input-file-{}".format(name) %}
    {%- call form_input_general(name, label, anid, small, info, displayerrors, horizontal) %}
        {{- input_file(name, readonly, defaultvalue, anid, accept=accept, aclass='form-control ' + (aclass or '')) }}
    {%- endcall %}
{%- endmacro %}

{% macro input_textarea(name, readonly=False, defaultvalue='', anid=none, aclass='form-control', maxlength=none, rows=3,
                        arialabel=none, attributes='') %}
    <textarea{{ dict(
        name=name,
        id=anid,
        class=aclass,
        rows=rows,
        maxlength=maxlength,
        disabled="disabled" if readonly,
        **{ 'aria-label': arialabel }
    )|xmlattr }} {{ attributes }}>
    {#- TODO sort if this is a list -#}
        {{- values.get(name, defaultvalue) -}}
    </textarea>
{%- endmacro %}

{% macro form_input_textarea(name, label='', info='', displayerrors=True, readonly=False, defaultvalue='', anid=none,
        aclass=none, small=False, maxlength=none, rows=3, horizontal=True, attributes='', markdown=False) %}
    {%- set anid = anid or "input-textarea-{}".format(name) %}
    {%- call form_input_general(name, label, anid, small, info, displayerrors, horizontal, markdown=markdown) %}
        {{- input_textarea(name, readonly, defaultvalue, anid, maxlength=maxlength, rows=rows, attributes=attributes,
                          aclass='form-control ' + (aclass or '')) }}
    {%- endcall %}
{%- endmacro %}

{# list as default value is not supported yet #}
{% macro input_checkbox(name, label='', value=True, defaultvalue='', readonly=False, actualreadonly=False, anid=none,
        aclass=none, inline=False, radio=False, arialabel=none, attributes='') -%}
    <label{% if inline %} class="{{"radio" if radio else "checkbox"}}-inline"{% endif %}>
        <input{{ dict(
            type="radio" if radio else "checkbox",
            name=name if not actualreadonly else ("readonly" + name),
            id=anid,
            class=aclass,
            value=value,
            checked="checked" if value|stringIn(values.getlist(name)) or (not name in values and value|string == defaultvalue),
            disabled="disabled" if readonly or actualreadonly,
            **{ 'aria-label': arialabel }
        )|xmlattr }} {{ attributes }}/>
        {{ label -}}
    </label>
    {# checkboxes do not support the readonly attribute, so we emulate it with a disabled select and a hidden input. #}
    {% if actualreadonly %}
        {{ input_hidden(name) }}
    {% endif %}
{%- endmacro %}

{% macro input_checkboxes(name, entries, readonly=False, actualreadonly=False, defaultvalue='', inline=False,
        radio=False, aclass=none, arialabeledby='', sort=False) %}
    <div{{ dict(
        role="radiogroup" if radio else "group",
        **{'aria-labelledby': arialabeledby}
    )|xmlattr }}>
        {%- if arialabel %}<legend class="sr-only">{{ arialabel }}</legend>{% endif %}
        {% set entries = entries|sort(attribute=1) if sort else entries %}
        {%- for entry_value, entry_label in entries %}
            {% if not inline -%}
                <div class="{{ "radio" if radio else "checkbox"}}{{" disabled" if readonly}}">
            {%- endif -%}
                {{ input_checkbox(name, entry_label, entry_value, defaultvalue, readonly, inline=inline, radio=radio,
                                  aclass=aclass) }}
            {%- if not inline %}</div>{% endif %}
            {# checkboxes do not support the readonly attribute, so we emulate it with a disabled select and a hidden input. #}
            {%- if actualreadonly -%}
                {{ input_hidden(name) }}
            {%- endif -%}
        {%- endfor %}
    </div>
{%- endmacro %}

{% macro form_input_checkbox(name, label="", value=True, info='', displayerrors=True, readonly=False,
        actualreadonly=False, defaultvalue='', anid=none, horizontal=True, small=False, attributes='') %}
    {#- This is the version for a single checkbox as opposed to form_input_checkboxes(). #}
    {%- set anid = anid or "input-checkbox-{}".format(name) %}
    <div class="form-group
        {{ ("has-warning" if is_warning(name) else "has-error") if name in errors }}
    ">
        <div{% if horizontal %} class="
            {{ "col-sm-6 col-sm-offset-2" if small else "col-sm-8 col-sm-offset-4" }}
        "{% endif %}>
            <div class="checkbox{{ " disabled" if readonly }}">
                {{ input_checkbox(name, label, value, defaultvalue, readonly, actualreadonly, anid,
                                  attributes=attributes) }}
            </div>
            {{- output_errors(name, displayerrors) }}
            {{- output_info(info) }}
        </div>
    </div>
{%- endmacro %}

{#- This is the version for multiple checkboxes as opposed to input_checkbox().
    entries is of type [(str, str)]. #}
{% macro form_input_checkboxes(name, entries, label='', info='', displayerrors=True, readonly=False, actualreadonly=False,
        defaultvalue='', small=False, radio=False, horizontal=True, aclass=none, labelid=none, sort=False) %}
    {%- if not labelid %}{% set labelid = "inputgroup-{}-label".format(name) %}{% endif %}
    {%- call form_input_general(name, label, '', small, info, displayerrors, horizontal, labelid) %}
        {{- input_checkboxes(name, entries, readonly=readonly, actualreadonly=actualreadonly, defaultvalue=defaultvalue,
                             radio=radio, aclass=aclass, arialabeledby=labelid, sort=sort) }}
    {%- endcall %}
{%- endmacro %}


{% macro input_select(name, entries, readonly=False, actualreadonly=False, defaultvalue=none, anid=none,
        aclass='form-control', nulloption=none, arialabel=none, attributes="", sort=False) %}
    <select{{ dict(
        name=name if not actualreadonly else ("readonly" + name),
        id=anid,
        class=aclass,
        disabled="disabled" if readonly or actualreadonly,
        **{ 'aria-label': arialabel }
    )|xmlattr }} {{ attributes }}>
        {%- if nulloption is not none %}
            <option value=""{% if values.get(name, defaultvalue) == none %} selected="selected"{% endif %}>
                {{- nulloption -}}
            </option>
        {%- endif %}
        {% set entries = entries|sort(attribute=1) if sort else entries %}
        {# Relevant for default: Use default value if key is unset or empty string or none #}
        {% set former_value = values.get(name, "")|string if values.get(name, "") is not none else "" %}
        {%- for value, label in entries %}
            {% if value in ("", none) and defaultvalue %}
                {# This leads to problems regarding defaultvalues. #}
                {{ raise(gettext("Empty string values with defaultvalue not supported. default: {} value: {}")
                    |format(defaultvalue|string, value|string)) }}
            {% endif %}
            <option value="{{ value }}"
                {%- if former_value == value|string or (former_value == "" and defaultvalue|string == value|string) %}
                    selected="selected"
                {% endif %}>
                {{- label -}}
            </option>
        {%- endfor %}
    </select>
    {# select tags do not support the readonly attribute, so we emulate it with a disabled select and a hidden input. #}
    {% if actualreadonly %}
        {{ input_hidden(name) }}
    {% endif %}
{%- endmacro %}

{% macro form_input_select(name, entries, label="", info='', displayerrors=True, readonly=False, actualreadonly=False,
        defaultvalue=none, nulloption=none, anid=none, small=False, horizontal=True, aclass="", attributes="", sort=False) %}
    {%- set anid = anid or "input-select-{}".format(name) %}
    {%- call form_input_general(name, label, anid, small, info, displayerrors, horizontal) %}
        {{- input_select(name, entries, readonly, actualreadonly, defaultvalue, anid, nulloption=nulloption,
                aclass="form-control " + aclass, attributes=attributes, sort=sort) }}
    {%- endcall %}
{%- endmacro%}

{% macro input_multi_select(name, entries, readonly=False, actualreadonly=False, anid=none,
        aclass='form-control', nulloption=none, arialabel=none, attributes="", sort=False) %}
    <select multiple {{ dict(
        name=name if not actualreadonly else ("readonly" + name),
        id=anid,
        class=aclass,
        disabled="disabled" if readonly or actualreadonly,
        **{ 'aria-label': arialabel }
    )|xmlattr }} {{ attributes }}>
        {%- if nulloption is not none %}
            <option value=""{% if values.get(name) == [] %} selected="selected"{% endif %}>
                {{- nulloption -}}
            </option>
        {%- endif %}
        {% set entries = entries|sort(attribute=1) if sort else entries %}
        {# This is necessary to convert the values to strings so we can check if they are currently selected #}
        {% set current_values = [] %}
        {% for value in values.get(name) %}
            {% do current_values.append(value|string) %}
        {% endfor %}
        {%- for value, label in entries %}
            <option value="{{ value }}"{%- if value|string in current_values %} selected="selected"{% endif %}>
                {{- label -}}
            </option>
        {%- endfor %}
    </select>
    {# select tags do not support the readonly attribute, so we emulate it with a disabled select and a hidden input. #}
    {% if actualreadonly %}
        {{ input_hidden(name) }}
    {% endif %}
{%- endmacro %}

{% macro form_input_multi_select(name, entries, label="", info='', displayerrors=True, readonly=False, actualreadonly=False,
        defaultvalue=none, nulloption=none, anid=none, small=False, horizontal=True, aclass="", attributes="", sort=False) %}
    {%- set anid = anid or "input-multi-select-{}".format(name) %}
    {%- call form_input_general(name, label, anid, small, info, displayerrors, horizontal) %}
        {{- input_multi_select(name, entries, readonly, actualreadonly, anid, nulloption=nulloption,
                aclass="form-control " + aclass, attributes=attributes, sort=sort) }}
    {%- endcall %}
{%- endmacro%}

{% macro input_static(value, anid=none) %}
    <div class="form-control-static"{% if anid %} id="{{ anid }}"{% endif %}>{{ value }}</div>
{%- endmacro %}

{% macro form_input_static(label="", info='', value='', anid=none, small=False, horizontal=True, aclass=none, icon=none) %}
    {%- if caller %}{% set value=caller() %}{% endif %}
    {%- call form_input_general(none, label, anid, small, info, False, horizontal) %}
        <div class="form-control-static {{ aclass }}"{% if anid %} id="{{ anid }}"{% endif %}>
            {{ make_icon(icon) if icon }}
            {{- value -}}
        </div>
    {%- endcall %}
{%- endmacro %}

{% macro input_submit(label="Save", value="True", name="submitform", anid=none, aclass='btn btn-primary', icon="check",
        readonly=False, title=none, ariahidden=false, formmethod=none, formaction=none, display_ignore_warnings=True) %}
    {% if has_warnings() and display_ignore_warnings %}
        {{ input_checkbox(name=IGNORE_WARNINGS_NAME, label=gettext("Ignore Warnings"), value=True, readonly=readonly) }}
    {% endif %}
    <button{{ dict(
        type="submit",
        name=name,
        id=anid,
        class=aclass,
        title=title,
        value=value,
        disabled="disabled" if readonly,
        formmethod=formmethod,
        formaction=formaction,
        **{ "aria-hidden": "true" if ariahidden }
    )|xmlattr }}>
        {{ make_icon(icon) if icon }}
        {{ label }}
    </button>
{%- endmacro %}

{% macro form_input_submit(label="Save", value="True", name="submitform", readonly=False, anid=none,
        aclass='btn btn-primary', icon="check", cancellink='', cancelvalue="Cancel",
        small=False, horizontal=True, title=none) %}
    {% if has_warnings() %}
        {{ form_input_checkbox(name=IGNORE_WARNINGS_NAME, label=gettext("Ignore Warnings"), value=True,
                               readonly=readonly, horizontal=horizontal, small=small) }}
    {% endif %}
    <div class="form-group mosp">
        <div{% if horizontal %} class="
            {{ "col-sm-offset-2 col-sm-10" if small else "col-sm-offset-4 col-sm-8" }}
        "{% endif %}>
            {{- input_submit(gettext(label), value, name, anid, aclass, icon, readonly, title, display_ignore_warnings=False) }}
            {%- if cancellink %}
                &emsp;{{ href(cancellink, gettext(cancelvalue), icon="times", aclass="btn btn-default cancel") }}
            {%- endif %}
        </div>
    </div>
{%- endmacro %}


{# ############################ #
 # Special purpose input macros #
 # ############################ #}

{% macro form_input_from_to(name1, name2, label='', info='', type='number', small=False, displayerrors=True,
        horizontal=True) %}
    <div class="form-group{{ " has-error" if name1 in errors or name2 in errors }}">
        <label class="control-label{% if horizontal %} {{ "col-sm-2" if small else "col-sm-4" }}{% endif %}">
            {{- label -}}
        </label>
        <div{% if horizontal %} class="{{ "col-sm-6" if small else "col-sm-8" }}"{% endif %}>
            <div class="input-group">
                <span class="input-group-addon">{% trans %}from{% endtrans %}</span>
                {{ input_text(name=name1, type=type, arialabel=gettext('%s from')|format(label)) }}
                <span class="input-group-addon">{% trans %}to{% endtrans %}</span>
                {{ input_text(name=name2, type=type, arialabel=gettext('%s to')|format(label)) }}
            </div>
            {{- output_errors(name1, displayerrors) }}
            {{- output_errors(name2, displayerrors) }}
            {{- output_info(info) }}
        </div>
    </div>
{% endmacro %}

{% macro event_field_input(fields, name=none, readonly=False, defaultvalue='', anid=none) %}
    {%- set name = name or "fields.{}".format(fields['field_name']) %}
    {%- if fields['entries'] %}
        {{- input_select(name=name, entries=fields['entries'], nulloption=nbsp,
                        readonly=readonly, defaultvalue=defaultvalue, anid=anid, sort=True) }}
    {%- else %}
        {% set datatypes = enums['FieldDatatypes'] %}
        {%- if fields['kind'] == datatypes.bool %}
            <div class="checkbox">
                {{- input_checkbox(name=name, readonly=readonly, defaultvalue=defaultvalue, anid=anid, label=fields['field_name']) -}}
            </div>
        {%- elif fields['kind'] == datatypes.str %}
            {{- input_textarea(name=name, readonly=readonly, defaultvalue=defaultvalue, anid=anid, rows=3) }}
        {%- elif fields['kind'] == datatypes.int %}
            {{- input_text(name=name, readonly=readonly, defaultvalue=defaultvalue, anid=anid, type="number",
                          placeholder="0") }}
        {%- elif fields['kind'] == datatypes.float %}
            {{- input_text(name=name, readonly=readonly, defaultvalue=defaultvalue, anid=anid, placeholder="0.0") }}
        {%- elif fields['kind'] == datatypes.date %}
            {{- input_text(name=name, readonly=readonly, defaultvalue=defaultvalue, anid=anid, type="date",
                          placeholder="YYYY-MM-DD") }}
        {%- elif fields['kind'] == datatypes.datetime %}
            {{- input_text(name=name, readonly=readonly, defaultvalue=defaultvalue, anid=anid, type="datetime-local") }}
        {%- else %}
            {{- input_text(name=name, readonly=readonly, defaultvalue=defaultvalue, anid=anid) }}
        {%- endif %}
    {%- endif %}
{%- endmacro %}

{% macro form_event_field_input(fields, name=none, label=none, info='', displayerrors=True, readonly=False,
                                defaultvalue='', anid=none, force_label=False) %}
    {%- set name = name or "fields.{}".format(fields['field_name']) %}
    {%- set label = label or fields['field_name'] %}
    {%- set anid = anid or "event-input-{}".format(name) %}
    {%- call form_input_general(name, (none if fields['kind'] == enums['FieldDatatypes'].bool and not force_label else label), anid, False,
                               info, displayerrors, True) %}
        {{- event_field_input(fields, name, readonly, defaultvalue, anid) }}
    {%- endcall %}
{%- endmacro %}

{# Macro to take care of all the meta dynamic row stuff.

This macro must be called, and the call body have to provide a generic row. The calling macro must take
  * id: the id of the row
  * row_class: css-class which is used to identify existing, new and prototype rows internally
  * is_new_row: bool which shows if the current row is a new row (drow-new or drow-prototype)
as arguments. #}
{% macro dynamic_row_meta(existing_ids, prefix="", add_prototype_row=True) %}
    {# Old items, already stored in the database #}
    {% for id in existing_ids %}
        {{- caller(id=id, row_class='drow-row', is_new_row=False) }}
    {% endfor %}

    {# Items that were added by the user but failed validation. They are still new and have no official id. #}
    {% set last_index = values.get(drow_last_index(prefix), 0) %}
    {% for i in range(1, last_index + 1) %}
        {{- caller(id=-i, row_class='drow-new', is_new_row=True)  }}
    {% endfor %}

    {# Prototype row. For non-JS users: an empty row with 'create'-checkbox, for JS: prototype for new rows. #}
    {% if add_prototype_row %}
        {{- caller(id=-last_index - 1, row_class='drow-prototype', is_new_row=True)  }}
    {% endif %}
{% endmacro %}


{# Macro for a general row, used in a dynamic row table.

   non-deletable rows have a disabled 'delete'-checkbox,
   readonly rows have all fields disabled
   aclass is used to pass classes to the row, such as drow-row, drow-prototype, drow-new
   newrow rows will have 'create' instead of 'delete' checkbox and have 'data-basename' attributes
   prefix is used to specify a string inserting before every parameter name #}
{% macro dynamic_row(id, tablename, columns, deletable=True, readonly=False, aclass="", newrow=False, prefix="") %}
    <tr class="{{ aclass }}" role="group" aria-label="{{ tablename }} {{ id }}">
        {% for column in columns %}
            {% set func = column['func'] %}
            {% set name = '{}{}_{}'.format(prefix, column['name'], id) %}
            <td {% if name in errors %}class="{{ "has-warning" if is_warning(name) else "has-error" }}"{% endif %}>
                {# TODO set the remaining items of colum as attributes to func #}
                {# this is a call for a generic util.input_* macro specified by the caller #}
                {{ func(name=name,
                        aclass='drow-input form-control' + " " + column.get('aclass', ""),
                        attributes=('data-basename="{}{}_"'.format(prefix, column['name'])|s if newrow else ''),
                        arialabel=gettext(column['label']),
                        readonly=readonly,
                        **column.get('func_additional_input', {})
                        ) }}
                {{ output_errors(name) }}
            </td>
        {% endfor %}

        <td>
            <span class="drow-buttonspace">
                {% if newrow %}
                    {{ util.input_checkbox("{}create_{}".format(prefix, id), label=gettext("Add"),
                                           attributes='data-basename="{}create_"'.format(prefix)|s, readonly=readonly,
                                           aclass='drow-indicator') }}
                {% else %}
                    {{ util.input_checkbox("{}delete_{}".format(prefix, id), label=gettext("Delete"),
                                           readonly=not deletable or readonly, aclass='drow-indicator') }}
                {% endif %}
            </span>
        </td>
    </tr>
{% endmacro %}

{# This macro creates a table which entries can be added, deleted and modified by the user.

   name:     the name of the table
   columns:  List of dicts. Each dict must contain a 'func' key, specifing the util.input_* macro for this column,
             the 'name' (mapping the input to a db field) and a 'label'.
   existing: a dict of already existing entries.
   locked:   iterable which contains all id of existing entries which must not be modified or deleted by the user
   readonly: if true, all input fields are disabled and no new row is shown
   modification_only: if true, no rows can be added or deleted, but they may be modified
   sortkey:  to sort existing
   prefix is used to specify a string inserting before every parameter name #}
{% macro dynamic_row_table(name, columns, existing, locked=[], readonly=False, modification_only=False, sortkey=none, prefix="") %}
    {% set prefix = prefix + '_' if prefix else '' %}
    <table class="table table-condensed" id="{{ prefix }}drow-table">
        <thead>
            <tr>
                {% for column in columns %}
                    <th>{% trans title=column['label']%}{{ title }}{% endtrans %}</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody>
            {% set sorted_existing = existing|keydictsort(sortkey) if sortkey else existing|dictsort %}
            {# Old items, already stored in the database #}
            {% for id, entry in sorted_existing %}
                {{ dynamic_row(id, name, columns, deletable=id not in locked and not modification_only,
                               readonly=readonly, aclass='drow-row', prefix=prefix) }}
            {% endfor %}
            {# Items that were added by the user but failed validation. They are still new and have no official id. #}
            {% set last_index_key = prefix+"create_last_index"  %}
            {% for i in range(1, values.get(last_index_key, 0) + 1) %}
                {{ dynamic_row(-i, name, columns, deletable=False, readonly=readonly, aclass='drow-new', newrow=True, prefix=prefix) }}
            {% endfor %}
            {# Prototype row. For non-JS users: an empty row with 'create'-checkbox, for JS: prototype for new rows. #}
            {% if not readonly and not modification_only %}
                {{ dynamic_row(-values.get(last_index_key, 0) - 1, name, columns, deletable=False, aclass='drow-prototype', newrow=True, prefix=prefix) }}
            {% endif %}
        </tbody>
    </table>
    {% if not (readonly or modification_only) %}
        <p>
            <button type="button" class="btn btn-success softhide pull-right" id="{{ prefix }}drow-addbutton">
                {{ make_icon('plus') }} {% trans %}Add {{ name }}{% endtrans %}
            </button>
        </p>
    {% endif %}
{% endmacro %}

{# Generate an anti CSRF (Cross-Site Request Forgery) token and add it as hidden input to an HTML form.

   The frontend application checks the anti CSRF token for every called endpoint which is marked for this check, which
   is the default for every POST-enabled endpoint. It validates the hash and checks the value against the login user's
   persona_id. This should prevent people from performing an CSRF attack, as they are unable to reproduce the hashed
   token.

   For protection against replay attacks, we use the default timeout of config.PARAMETER_TIMEOUT #}
{% macro anti_csrf_token(target, token_name = ANTI_CSRF_TOKEN_NAME, token_payload = ANTI_CSRF_TOKEN_PAYLOAD) %}
    {{ input_hidden(token_name, encode_anti_csrf(target, token_name, token_payload, persona_id=user.persona_id)) }}
{% endmacro %}


{% macro print_questionnaire_entry(entry) %}
    {# Field entry #}
    {% if entry['field_id'] %}
        {% with FIELD = ambience['event']['fields'][entry['field_id']],
                readonly = entry['readonly'] or is_locked or ambience['event']['is_archived'] %}
            <div id="questionnaire_field_entry_{{ FIELD['field_name'] }}">
            {% if FIELD['entries'] %}
                {{ form_input_select(name=FIELD['field_name'], entries=FIELD['entries'],
                                          label=entry['title'], info=entry['info'],
                                          readonly=readonly,
                                          defaultvalue=entry['default_value'] if not readonly else "") }}
            {% else %}
                {% set datatypes = enums['FieldDatatypes'] %}
                {% if FIELD['kind'] == datatypes.bool %}
                    {{ form_input_checkbox(
                        name=FIELD['field_name'], label=entry['title'], info=entry['info'],
                        readonly=readonly, defaultvalue=entry['default_value'] if not readonly else "") }}
                {% elif FIELD['kind'] == datatypes.str  %}
                    {% if entry['input_size'] %}
                        {{ form_input_textarea(
                            name=FIELD['field_name'], label=entry['title'], info=entry['info'],
                            readonly=readonly, defaultvalue=entry['default_value'] if not readonly else "",
                            rows=(1+entry['input_size']*2)) }}
                    {% else %}
                        {{ form_input_text(
                            name=FIELD['field_name'], label=entry['title'], info=entry['info'],
                            readonly=readonly, defaultvalue=entry['default_value'] if not readonly else "") }}
                    {% endif %}
                {% else %}
                    {{ form_event_field_input(
                        FIELD, name=FIELD['field_name'], label=entry['title'], info=entry['info'],
                        readonly=readonly, defaultvalue=entry['default_value'] if not readonly else "") }}
                {% endif %}
            {% endif %}
            </div>
        {% endwith %}

    {# Text-only entry #}
    {% else %}
        {% if entry['title'] %}
            {% if entry['kind'] == enums['QuestionnaireUsages'].additional %}
                <h3 class="heading-underline">{{ entry['title'] }}</h3>
            {% else %}
                <h4 class="heading-underline">{{ entry['title'] }}</h4>
            {% endif %}
        {% endif %}
        {% if entry['info'] %}
            {{ entry['info']|md }}
        {% endif %}
    {% endif %}
{% endmacro %}

{% macro print_questionnaire_result(entry, registration) %}
    {% if entry['field_id'] %}
        {% with FIELD = ambience['event']['fields'][entry['field_id']] %}
            <div id="questionnaire_field_result_{{ FIELD['field_name'] }}">
                <dt>{{ entry['title'] }}</dt>
                <dd>
                    {% if FIELD['entries'] %}
                        {% set chosen = registration['fields'].get(FIELD['field_name'])|string %}
                        {% for option, display_name in FIELD['entries'] %}
                            {% if chosen == option %}
                                {{ display_name }}
                            {% endif %}
                         {% endfor %}
                    {% elif FIELD['kind'] == enums['FieldDatatypes'].bool %}
                        {{ deko_checkbox(
                            checked=registration['fields'].get(FIELD['field_name'])) }}
                    {% elif FIELD['kind'] == enums['FieldDatatypes'].date %}
                        {{ registration['fields'].get(FIELD['field_name'])
                           |date(lang=lang, passthrough=True) }}
                    {% elif FIELD['kind'] == enums['FieldDatatypes'].datetime %}
                        {{ registration['fields'].get(FIELD['field_name'])
                           |datetime(lang=lang, passthrough=True) }}
                    {% elif FIELD['kind'] == enums['FieldDatatypes'].float %}
                        {{ registration['fields'].get(FIELD['field_name'])|decimal(lang=lang) }}
                    {% else %}
                        {{ registration['fields'].get(FIELD['field_name'])|linebreaks }}
                    {% endif %}
                </dd>
            </div>
        {% endwith %}
    {% endif %}
{% endmacro %}

{# Macro for a general questionnaire part, that can have each role in the DynamicRow workflow.
   aclass is used to pass classes to the row, such as drow-row, drow-prototype, drow-new
   newrow rows will have 'create' instead of 'delete' checkbox and have 'data-basename' attributes #}
{% macro print_questionnaire_config(part_id, kind, aclass="", newrow=False) %}
    <div class="panel panel-default {{ aclass }}">
        <div class="panel-body">
            <div class="row">
                <div class="col-md-6">
                    {{ form_input_text(name="title_{}".format(part_id), label=gettext("Title_[[name of an entity]]"),
                                            attributes=('data-basename="title_"'|s if newrow else ''),
                                            aclass='input-title drow-input', horizontal=false) }}
                    {{ form_input_textarea(name="info_{}".format(part_id), label=gettext("Text"),
                                                attributes=('data-basename="info_"'|s if newrow else ''),
                                                aclass='input-info drow-input', horizontal=false,
                                                info=gettext("Supports %(infolink)s for “Text-Only” fields.")|format(
                                                    infolink=href(docurl("Handbuch_Markdown"),
                                                                       gettext("Markdown"),
                                                                       title=gettext("Short Markdown summary")))|s) }}
                </div>
                <div class="col-md-6">
                    {{ form_input_select("field_id_{}".format(part_id), label=gettext("Query"),
                                              entries=registration_fields|keydictsort(EntitySorter.event_field)|dict_entries('id', 'field_name'),
                                              nulloption=gettext("— Only Text —"),
                                              attributes=('data-basename="field_id_"'|s if newrow else ''),
                                              aclass='input-field drow-input', horizontal=False) }}
                    {{ form_input_select(
                        "input_size_{}".format(part_id), label=gettext("Input Size"), entries=(
                            (0, gettext("singleline")), (1, gettext("multiline")),
                            (2, gettext("multiline") + "+"), (3, gettext("multiline") + "++")),
                        attributes=('data-basename="input_size_"'|s if newrow else ''),
                        aclass='input-inputsize drow-input', horizontal=False) }}
                    {{ form_input_textarea(
                        "default_value_{}".format(part_id), label=gettext("Default Value"), rows=2,
                        attributes=('data-basename="default_value_"'|s if newrow else ''),
                        aclass='input-defaultvalue drow-input', horizontal=False) }}
                    <div class="form-group row">
                        <div class="col-sm-8">
                            <div class="checkbox">
                                {{ input_checkbox("readonly_{}".format(part_id), label=gettext("read-only"),
                                                       attributes=('data-basename="readonly_"'|s if newrow else ''),
                                                       aclass='input-readonly drow-input',
                                                       readonly=(not values["readonly_{}".format(part_id)]
                                                                 and (kind and not kind.allow_readonly()))) }}
                                {{ output_errors("readonly_{}".format(part_id), wrapper=True) }}
                            </div>
                        </div>
                        <div class="col-sm-4 text-right">
                            <span class="drow-buttonspace">
                                {% if newrow %}
                                    {{ input_checkbox("create_{}".format(part_id), label=gettext("Add"),
                                                           attributes='data-basename="create_"'|s,
                                                           aclass='drow-indicator') }}
                                {% else %}
                                    {{ input_checkbox("delete_{}".format(part_id), label=gettext("Remove"),
                                                           aclass='drow-indicator') }}
                                {% endif %}
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endmacro %}

{# Generate a list of admin view toggle buttons. Should be used in the navigation sidebar.

   The properties of the individual buttons are specified through the `views` argument, which is an iterable of
   3-tuples. Each tuple defines (label, view_names, relevant_views) of one button:
     * `label` (1st tuple entry) defines the caption of the button. Should be internationalized.
     * `view_names` (2nd tuple entry) defines a list of admin_views to be toggled by this button together.
     * `relevant_views` (3rd tuple entry) defines a list of views, which are the subset of `view_names` that is relevant
       in the current page's context. The button is only displayed, if one of those views is available to the user.
       For convenience, `relevant_views` may be set to none, in which case all `view_names` are considered relevant.
       Example: A button in the Core realm may toggle all user admin views (`core_user`, `cde_user, `event_user`, ...),
       but should only be shown to core admins, i.e. users who have the `core_user` view available.
 #}
{% macro admin_views_toggle(views) %}
    {% set inner = _admin_views_toggle_inner(views) %}
    {% if inner %}
        <hr />
        <form action="{{ cdedblink('core/modify_active_admin_views') }}" method="post" id="adminviewstoggleform">
            {% if original_request and original_request.url %}
                {{ input_hidden("wants", encode_parameter("core/modify_active_admin_views", "wants",
                                                          original_request.url, user.persona_id, timeout=none)) }}
            {% endif %}
            <div class="list-group tear-down">{{ inner }}</div>
        </form>
    {% endif %}
{% endmacro %}

{# Un-inlined part of admin_views_toggle() to allow detection of empty list of views with the limited capabilities of
   jinja #}
{% macro _admin_views_toggle_inner(views) -%}
    {% for label, view_names, relevant_views in views -%}
        {% set relevant_views = relevant_views if relevant_views is not none else view_names -%}
        {% if (relevant_views|set).intersection(user.available_admin_views) %}
            {# The button is "deactivated" as long as there are more "relevant views" which are available for the
               user but are not enabled yet. #}
            {% set active = not (relevant_views|set).intersection(user.available_admin_views - user.admin_views) -%}
            <button{{ dict(
                type="submit",
                name="view_specifier",
                value=("-" if active else "+") + view_names|join(','),
                class="list-group-item list-group-item-info" + (" active" if active else ""),
                title=(gettext("Hide %(label)s") if active else gettext("Show %(label)s"))|format(label=label)
            )|xmlattr }}>
                {{- make_icon('wrench') }} {{ label -}}
                {% if active %} <span class="sr-only">{% trans %}(enabled){% endtrans %}</span>{% endif -%}
            </button>
        {% endif -%}
    {% endfor -%}
{% endmacro %}

{#
    Creates a HTML compliant mailto: URL (though not neccessarily RFC compliant)
    Additional header such as to, subject, body, cc, or bcc can be passed as kwargs
#}
{% macro mailto(address, name) -%}
mailto:
{%- if name is defined %}{{ "{}%3C{}%3E".format(name|urlencode, address) }}{% else %}{{ address }}{% endif %}
{%- if kwargs %}?{{ kwargs|urlencode }}{% endif %}
{%- endmacro %}

{% macro username_mailto(persona, email=none) -%}
    {% set given_names = persona.get("given_names", persona.get("persona.given_names", "")) %}
    {% set display_name = persona.get("display_name", persona.get("persona.display_name", "")) %}
    {% set forename = display_name if display_name and display_name in given_names else given_names %}
    {{ href(
        mailto(
            address=email or persona.get("username", persona.get("persona.username", "")),
            name="{} {}".format(
                forename,
                persona.get("family_name", persona.get("persona.family_name", ""))
            )
        ),
        email or persona.get("username", persona.get("persona.username", ""))
    ) }}
{%- endmacro %}

{% macro meta_info_banner(fieldname) %}
    {% if meta_info.get(fieldname) %}
        {% call bootstrap_panel() %}
            {{ meta_info.get(fieldname)|md }}
        {% endcall %}
    {% endif %}
{% endmacro %}

{% macro notification(ntype, id) %}
    {% with icontypes = {"success": "check-circle", "info": "info-circle", "warning": "exclamation-circle",
                         "error" : "times-circle"},
            alerttypes = {"success": "success", "info": "info", "warning": "warning", "error": "danger"},
            messagetypes = {"success": _("Success!"), "info": _("Info!"),
                            "warning": _("Warning!"), "error": _("Error!")} %}
        <div class="alert alert-{{ alerttypes[ntype] }}" role="alert" {% if id %}id="{{ id }}"{% endif %}>
            {{ make_icon( icontypes[ntype] ) }}
            <strong>{{ messagetypes[ntype] }}</strong>
            <span class="notificationMessage">{{ caller() }}</span>
        </div>
    {% endwith %}
{%- endmacro %}


{# Macro to unify the style of headings with context (events, personas, assemblies, ...) #}
{% macro context_heading(title, subtitle=none, icon=none, icon_arialabel=none, doclink=none, doclink_anchor=none) %}
    {% if doclink %}
        {{ _doclink(doclink, anchor=doclink_anchor) }}
    {% endif %}
    <h1 class="title">
        {{ title }}
        {% if subtitle %}
            <small>
                {{ make_icon(icon, arialabel=icon_arialabel) }}{{ nbsp }}{{ subtitle }}
                {% if caller %}{{ caller() }}{% endif %}
            </small>
        {% endif %}
    </h1>
{% endmacro %}


{% macro print_doppelganger(persona, link=False) %}
    {% if link %}
        {{ persona_anchor(persona, given_and_display_names=True) }}
    {% else %}
        {{ persona_name(persona, given_and_display_names=True) }}
    {% endif %}
    {%- if persona['birth_name'] %}
        ({{ persona['birth_name'] }})
    {%- endif %}
    {% if persona['is_archived'] %}
        (<i>{{ gettext("archived") }}</i>)
    {% else %}
        &lt;{{ persona['username'] }}&gt;
    {% endif %}
    {%- if persona['birthday'] %}
        ({{ gettext("born") }}
        {{ persona['birthday']|date(lang=lang) or "-" }})
    {% endif %}
    {{ persona['id']|cdedbid }}
    {%- if not persona['is_member'] %}
        {{ gettext("(not a member)") }}
    {%- elif persona['trial_member'] %}
        {{ gettext("(trial member)") -}}
    {% endif -%}
{% endmacro %}
